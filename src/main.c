/**
 * Copyright (c) 2024 Adrian Siekierka
 *
 * 240p-test-ws is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option)
 * any later version.
 *
 * 240p-test-ws is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with 240p-test-ws. If not, see <https://www.gnu.org/licenses/>.
 */

#include <string.h>
#include <wonderful.h>
#include <ws.h>
#include <ws/display.h>
#ifdef __WONDERFUL_WWITCH__
#include <sys/bios.h>
#endif

#include "../build/assets/fonts.h"
#include "main.h"

#define IRAM_IMPLEMENTATION
#include "iram.h"

// === General constants, IRQ handler ===

volatile uint16_t vbl_ticks = 0;
static uint16_t last_keys = 0;
uint16_t curr_keys = 0;

uint16_t scan_keys(void) {
#ifdef __WONDERFUL_WWITCH__
	curr_keys = key_hit_check_with_repeat();
	return curr_keys;
#else
	last_keys = curr_keys;
	curr_keys = ws_keypad_scan();
	return curr_keys & ~last_keys;
#endif
}

#ifndef __WONDERFUL_WWITCH__
__attribute__((interrupt))
void __far vblank_int_handler(void) {
        ws_hwint_ack(HWINT_VBLANK);
        vbl_ticks++;
}

void vblank_wait(void) {
        uint16_t vbl_ticks_last = vbl_ticks;

        while (vbl_ticks == vbl_ticks_last) {
                cpu_halt();
        }
}

void wait_keypress(void) {
	while (!scan_keys()) vblank_wait();
}
#else
void vblank_wait(void) {
	sys_wait(1);
}

void wait_keypress(void) {
	key_wait();
}

static const char __wf_rom display_exit_name[] = "Exit to Freya";
void display_exit(void *userdata) {
	bios_exit();
}
#endif

// === About screen ===

static const char __wf_rom main_menu_name[] = "- 144p Test Suite for WS (0.2.1) -";

// @ - force left align
static const char __wf_rom empty_line[] = "";

static const char __wf_rom about_line03[] = "(c) 2024 Adrian \"asie\" Siekierka";
static const char __wf_rom about_line04[] = "Original project by Artemio Urbina";

static const char __wf_rom about_line06[] = "@License GPLv3+: GNU GPL version 3 or later";
static const char __wf_rom about_line07[] = "@<https://gnu.org/licenses/gpl.html>";
static const char __wf_rom about_line08[] = "@This is free software: you are free to change";
static const char __wf_rom about_line09[] = "@and redistribute it.";
static const char __wf_rom about_line10[] = "@There is NO WARRANTY, to the extent permitted";
static const char __wf_rom about_line11[] = "@by law.";

static const char __wf_rom * __wf_rom about_lines[] = {
	empty_line,
	empty_line,
	main_menu_name,
	empty_line,
	about_line03,
	about_line04,
	empty_line,
	about_line06,
	about_line07,
	about_line08,
	about_line09,
	about_line10,
	about_line11,
	NULL
};

static const char __wf_rom display_about_name[] = "About";
static void display_about(void *userdata) {
	// This uses the tile/map layout generated by display_menu.
	memset(MEM_TILE(0), 0, 0x2000 - 64);
	ws_screen_modify_tiles(screen_1, ~SCR_ENTRY_PALETTE_MASK, 0, 0, 1, 28, 16);

	const char __wf_rom* __wf_rom* about_line = about_lines;
	int i = 0;

	while (*about_line) {
		const char __wf_rom *line = *(about_line++);
		if (*line == '@') {
			line++;
			vwf8_draw_string((uint8_t __wf_iram*) MEM_TILE(i), line, 4);
		} else {
			int line_width = vwf8_get_string_width(line);
			int mx = (DISPLAY_WIDTH_PX - line_width) >> 1;
			vwf8_draw_string((uint8_t __wf_iram*) MEM_TILE(i), line, mx);
		}
		i += 32;
	}

	wait_keypress();
}

// === Test patterns ===

static const char __wf_rom display_color_bars_name[] = "Color bars";
void display_color_bars(void *userdata);

static const char __wf_rom display_color_bleed_name[] = "Color bleed check";
void display_color_bleed(void *userdata);

static const char __wf_rom display_drop_shadow_name[] = "Drop shadow test";
void display_drop_shadow(void *userdata);

static const char __wf_rom display_full_color_name[] = "Full color palette";
void display_full_color(void *userdata);

static const char __wf_rom display_grey_ramp_name[] = "Grey ramp";
void display_grey_ramp(void *userdata);

static const char __wf_rom display_grid_name[] = "Grid";
void display_grid(void *userdata);

static const char __wf_rom display_grid_scroll_name[] = "Grid scroll test";
void display_grid_scroll(void *userdata);

static const char __wf_rom display_pluge_name[] = "PLUGE";
void display_pluge(void *userdata);

static const char __wf_rom display_solid_color_name[] = "Solid color";
void display_solid_color(void *userdata);

static const char __wf_rom display_stripes_name[] = "Stripes/Checkerboard";
void display_stripes(void *userdata);

// === Menu system ===

#define MF_COLOR_ONLY (1 << 0)
typedef struct {
	const char __wf_rom *name;
	void (*action)(void*);
	void *userdata;
	uint16_t flags;
} menu_entry_t;
#define MENU_ENTRY_TITLE(title) { title ## _name, NULL, NULL, 0 }
#define MENU_ENTRY(func, data, flags) { func ## _name, func, data, flags }
#define MENU_ENTRY_END() { NULL, NULL, NULL, 0 }

static const menu_entry_t __wf_rom main_menu_entries[] = {
	MENU_ENTRY_TITLE(main_menu),
	MENU_ENTRY(display_pluge, NULL, 0),
	MENU_ENTRY(display_color_bars, NULL, MF_COLOR_ONLY),
	MENU_ENTRY(display_solid_color, NULL, 0),
#ifndef __WONDERFUL_WWITCH__
	MENU_ENTRY(display_full_color, NULL, MF_COLOR_ONLY),
	MENU_ENTRY(display_grey_ramp, NULL, 0),
#endif
	MENU_ENTRY(display_grid, NULL, 0),
	MENU_ENTRY(display_drop_shadow, NULL, 0),
#ifndef __WONDERFUL_WWITCH__
	MENU_ENTRY(display_grid_scroll, NULL, 0),
#endif
	MENU_ENTRY(display_stripes, NULL, 0),
	MENU_ENTRY(display_color_bleed, NULL, MF_COLOR_ONLY),
	MENU_ENTRY(display_about, NULL, 0),
#ifdef __WONDERFUL_WWITCH__
	MENU_ENTRY(display_exit, NULL, 0),
#endif
	MENU_ENTRY_END()
};

static const uint16_t __wf_rom tile_bg[8] = { 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFF00, 0xFFFF, 0x00 };

static bool can_use_entry(const menu_entry_t __wf_rom* entry) {
	if (entry->flags & MF_COLOR_ONLY) {
		if (!ws_system_is_color()) {
			return false;
		}
	}
	return true;
}

__attribute__((noinline))
static int display_menu_init(const menu_entry_t __wf_rom* entries, int menu_y) {
#ifndef __WONDERFUL_WWITCH__
	cpu_irq_disable();
	ws_hwint_set_handler(HWINT_IDX_VBLANK, vblank_int_handler);
	ws_hwint_set(HWINT_VBLANK);
	cpu_irq_enable();
#endif

	outportw(IO_DISPLAY_CTRL, 0x0700);
	outportb(IO_SCR_BASE, SCR1_BASE(screen_1) | SCR2_BASE(screen_2));
	ws_system_mode_set(WS_MODE_MONO);

	int menu_count = 0;

	memset(MEM_TILE(0), 0, 0x2000 - 16);
	memcpy(MEM_TILE(511), tile_bg, sizeof(tile_bg));

	ws_display_set_shade_lut(SHADE_LUT_DEFAULT);
	outportw(IO_SCR_PAL_0, MONO_PAL_COLORS(1, 7, 3, 0));
	outportw(IO_SCR_PAL_1, MONO_PAL_COLORS(7, 0, 3, 0));
	outportw(IO_SCR_PAL_2, MONO_PAL_COLORS(1, 3, 3, 0));

	// Initialize tile layout
	for (int ix = 0; ix < 28; ix++) {
		ws_screen_put_tile(screen_1, 511, ix, 0);
		ws_screen_put_tile(screen_1, 511 | SCR_ATTR_FLIP_V, ix, 17);

		for (int iy = 0; iy < 16; iy++)
			ws_screen_put_tile(screen_1, ((iy << 5) + ix), ix, iy + 1);
	}
	ws_screen_modify_tiles(screen_1, 0xFFFF, SCR_ENTRY_PALETTE(1), 0, menu_y + 2, 28, 1);

	// Draw title
	{
		const char __wf_rom *title = (entries - 1)->name;
		int title_w = vwf8_get_string_width(title);
		int mx = (DISPLAY_WIDTH_PX - title_w) >> 1;
		vwf8_draw_string((uint8_t __wf_iram*) MEM_TILE(0), title, mx);
	}

	const menu_entry_t __wf_rom* drawn_entry = entries;

	// Draw entries
	{
		int my = 32;
		while (drawn_entry->action) {
			if (!can_use_entry(drawn_entry))
				ws_screen_modify_tiles(screen_1, 0xFFFF, SCR_ENTRY_PALETTE(2), 0, (my >> 5) + 1, 28, 1);
			vwf8_draw_string((uint8_t __wf_iram*) MEM_TILE(my), drawn_entry->name, 4);
			drawn_entry++;
			menu_count++;
			my += 32;
		}
	}

	outportw(IO_DISPLAY_CTRL, DISPLAY_SCR1_ENABLE);
	return menu_count;
}

__attribute__((optimize("-O0")))
void display_menu(const menu_entry_t __wf_rom* entries) {
	int menu_y = 0;
	entries++;

menu_redraw:
	; int menu_count = display_menu_init(entries, menu_y);

	while (true) {
		vblank_wait();
		int last_menu_y = menu_y;
		uint16_t keys_pressed = scan_keys();
		if (keys_pressed & KEY_A) {
			entries[menu_y].action(entries[menu_y].userdata);
			goto menu_redraw;
		}
		if (keys_pressed & KEY_X1) {
			do {
				if (menu_y == 0) menu_y = menu_count;
				menu_y--;
			} while (!can_use_entry(entries + menu_y));
		}
		if (keys_pressed & KEY_X3) {
			do {
				menu_y++;
				if (menu_y >= menu_count) menu_y = 0;
			} while (!can_use_entry(entries + menu_y));
		}
		if (menu_y != last_menu_y) {
			ws_screen_modify_tiles(screen_1, 0x01FF, SCR_ENTRY_PALETTE(0), 0, last_menu_y + 2, 28, 1);
			ws_screen_modify_tiles(screen_1, 0x01FF, SCR_ENTRY_PALETTE(1), 0, menu_y + 2, 28, 1);
		}
	}
};

void main(void) {
	display_menu(main_menu_entries);
	while(1);
}

